<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASK ARIA â€” PC Build Assistant</title>
    <style>
      :root {
        --teal: #007c89;
        --bg: #ffffff;
        --bubble: #e8edf1;
        --chip: #ffd7d0;
        --chip-text: #3b1f1f;
        --muted: #6b7280;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
      }

      body {
        background: var(--bg);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        padding: 2px;
      }

      .phone {
        background: var(--bg);
        width: 450px;
        max-width: 100%;
        height: 800px;
        max-height: 100vh;
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .topbar {
        background: var(--teal);
        color: #fff;
        padding: 14px 18px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .topbar .icons {
        display: flex;
        gap: 10px;
      }

      .topbar button {
        background: transparent;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 16px;
      }

      .content {
        flex: 1;
        overflow-y: auto;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        scroll-behavior: smooth;
      }

      .bubble-assistant {
        align-self: flex-start;
        background: var(--bubble);
        color: #0a2026;
        padding: 14px 16px;
        border-radius: 16px;
        max-width: 95%;
        font-weight: 600;
        line-height: 1.4;
        word-wrap: break-word;
      }

      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 6px;
      }

      .chip {
        background: var(--chip);
        color: var(--chip-text);
        padding: 10px 14px;
        border-radius: 999px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }

      .chip:hover {
        background: #ffc2b8;
        transform: scale(1.03);
      }

      .inputbar {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 0);
        left: 0;
        right: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px;
        border-top: 1px solid #eee;
        background: #fff;
        z-index: 60;
      }

      .phone {
        padding-bottom: 84px;
      }

      .pill {
        flex: 1;
        background: var(--chip);
        padding: 12px 16px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--chip-text);
        font-weight: 600;
      }

      .pill textarea {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        color: inherit;
        font-weight: 600;
        resize: none;
        overflow: hidden;
        line-height: 1.2;
        font-family: inherit;
        font-size: inherit;
        padding: 0;
        min-height: 1.2em;
      }

      .send-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: var(--teal);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
      }

      /* Slim, semi-transparent scrollbar styling */
      .content::-webkit-scrollbar {
        width: 6px;
        /* thinner scrollbar */
      }

      .content::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
        /* light gray, semi-transparent */
        border-radius: 10px;
        transition: background 0.3s ease;
      }

      .content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.35);
        /* darker on hover */
      }

      .content::-webkit-scrollbar-track {
        background: transparent;
        /* invisible track */
      }

      .send-btn:hover {
        background: #026b77;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }

        .phone {
          width: 100%;
          height: calc(100vh - 20px);
          max-height: none;
          border-radius: 0;
        }

        .content {
          padding: 14px;
        }

        .bubble-assistant {
          max-width: 100%;
          font-size: 15px;
        }

        .chip {
          font-size: 14px;
          padding: 8px 12px;
        }

        .pill {
          padding: 10px 12px;
          font-size: 14px;
        }

        .send-btn {
          width: 40px;
          height: 40px;
          font-size: 18px;
        }
      }
    </style>
  </head>

  <body>
    <div class="phone">
      <div class="content" id="chat"></div>

      <div class="inputbar">
        <div class="pill">
          âœ¦
          <textarea
            id="query"
            placeholder="e.g. Intel Core i3 13100 compatible Motherboard"
            aria-label="Ask ARIA"
            rows="1"
          ></textarea>
        </div>
        <div class="send-btn" id="send">â–²</div>
      </div>
    </div>
    <script>
      (function () {
        // Use the same origin as the page to avoid origin mismatches
        const API_BASE = window.location.origin;

        // DOM refs (guarded)
        const chat = document.getElementById("chat");
        const qInput = document.getElementById("query");
        const sendBtn = document.getElementById("send");

        if (!chat || !qInput || !sendBtn) {
          console.error(
            "ARIA frontend: missing required DOM elements (#chat, #query, #send)"
          );
          return;
        }

        // ------------------ keyboard/viewport helpers ------------------
        // Keep the focused input visible when the on-screen keyboard opens

        function ensureInputVisible(el) {
          if (!el) return;
          // modern browsers: use visualViewport when available
          if (window.visualViewport) {
            setTimeout(() => {
              const rect = el.getBoundingClientRect();
              const vv = window.visualViewport;
              // how far the bottom of the input is below the viewport
              const overlap = rect.bottom - vv.height;
              if (overlap > -10) {
                // scroll by the minimal amount to make it visible
                window.scrollBy({
                  top: overlap + 16,
                  left: 0,
                  behavior: "smooth",
                });
              }
              try {
                chat.scrollTop = chat.scrollHeight;
              } catch (e) {}
            }, 50);
            return;
          }

          // fallback
          setTimeout(() => {
            try {
              el.scrollIntoView({ behavior: "smooth", block: "center" });
            } catch (e) {}
            try {
              chat.scrollTop = chat.scrollHeight;
            } catch (e) {}
          }, 50);
        }

        // Listen for focus on the textarea
        qInput.addEventListener("focus", (e) => ensureInputVisible(e.target));

        // Use visualViewport resize to detect keyboard open; fallback to window.resize
        let lastVVHeight = window.visualViewport
          ? window.visualViewport.height
          : window.innerHeight;
        function onViewportResize() {
          const currentHeight = window.visualViewport
            ? window.visualViewport.height
            : window.innerHeight;
          if (currentHeight < lastVVHeight) {
            // keyboard probably opened
            ensureInputVisible(qInput);
            // optional: increase bottom padding so fixed input won't overlap content
            const inset = Math.max(0, window.innerHeight - currentHeight);
            document.querySelector(".phone").style.paddingBottom =
              inset + 84 + "px";
          } else {
            // keyboard probably closed â€” restore base padding
            document.querySelector(".phone").style.paddingBottom = "84px";
          }
          lastVVHeight = currentHeight;
        }

        if (window.visualViewport) {
          window.visualViewport.addEventListener("resize", onViewportResize);
        } else {
          window.addEventListener("resize", onViewportResize);
        }

        function scrollChatToBottom() {
          try {
            chat.scrollTop = chat.scrollHeight;
          } catch (e) {
            /* ignore */
          }
        }

        // ðŸ§ USER MESSAGE
        function appendUser(text) {
          const wrapper = document.createElement("div");
          wrapper.style.alignSelf = "flex-end";
          wrapper.style.background = "#d0f0e0";
          wrapper.style.padding = "12px 16px";
          wrapper.style.borderRadius = "12px";
          wrapper.style.color = "#0a2026";
          wrapper.style.fontWeight = "600";
          wrapper.style.maxWidth = "80%";
          wrapper.style.wordWrap = "break-word";
          wrapper.textContent = text;
          chat.appendChild(wrapper);
          scrollChatToBottom();
        }

        // ðŸ¤– ASSISTANT MESSAGE
        function appendAssistant(text) {
          const wrapper = document.createElement("div");
          wrapper.className = "bubble-assistant";
          wrapper.style.whiteSpace = "pre-wrap";
          wrapper.textContent = text;
          chat.appendChild(wrapper);
          scrollChatToBottom();
          return wrapper;
        }

        // Generic chip renderer used by multiple handlers
        function renderChips(
          items = [],
          onClickFn = null,
          labelKey = "text",
          showPrice = true
        ) {
          if (!Array.isArray(items) || items.length === 0) return;
          const row = document.createElement("div");
          row.className = "chip-row";

          items.forEach((c) => {
            const chip = document.createElement("div");
            chip.className = "chip";
            chip.tabIndex = 0;
            chip.style.cursor = "pointer";
            chip.setAttribute("role", "button");

            // Items may be "chip" objects or build objects â€” try to be flexible
            const text =
              typeof c === "string"
                ? c
                : c[labelKey] ||
                  (c.meta && c.meta.name) ||
                  c.text ||
                  c.id ||
                  c.name ||
                  "Unknown";

            const priceVal =
              c && (c.price || (c.meta && c.meta.price))
                ? c.price || c.meta.price
                : "";
            const price = priceVal ? ` â€” ${priceVal}` : "";

            chip.textContent = showPrice ? `${text}${price}` : text;

            // attach id if present for lookupChip (dataset is easiest to pick up)
            if (c && c.id) chip.dataset.chipid = c.id;

            // support encoded build payload that's used by renderBuildRecommendations
            if (c && c.build_payload) chip.dataset.build = c.build_payload;

            const activate = (ev) => {
              try {
                if (typeof onClickFn === "function") {
                  const maybe = onClickFn(c, ev);
                  if (maybe !== false) return;
                }

                const explicitId = c && (c.id || chip.dataset.chipid);
                if (explicitId) return lookupChip(explicitId);

                if (chip.dataset && chip.dataset.build) return onBuildTap(chip);

                if (c && c.meta && c.meta.name && c.type) {
                  const id = `${c.type}:${(c.meta.name || "")
                    .toLowerCase()
                    .replace(/\s+/g, "-")}`;
                  return lookupChip(id);
                }

                if (c && c.type && text) {
                  const id = `${c.type}:${text
                    .toLowerCase()
                    .replace(/\s+/g, "-")}`;
                  return lookupChip(id);
                }
              } catch (err) {
                console.error("Chip click handler error:", err);
              }
            };

            chip.addEventListener("click", activate);
            chip.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                activate(e);
              }
            });

            row.appendChild(chip);
          });

          chat.appendChild(row);
          scrollChatToBottom();
        }

        // ðŸ’¸ BUILD RECOMMENDATIONS (Tapable)
        function renderBuildRecommendations(results, maxBuilds = 3) {
          appendAssistant("Here are some recommended builds you can explore:");

          const row = document.createElement("div");
          row.className = "chip-row";

          results.slice(0, maxBuilds).forEach((build, idx) => {
            const chip = document.createElement("div");
            chip.className = "chip";
            chip.tabIndex = 0;
            chip.style.cursor = "pointer";
            chip.setAttribute("role", "button");

            const price = build.total_price || null;
            const priceLabel = price ? ` â€” ${formatPrice(price)}` : "";
            chip.textContent = `Build ${idx + 1}${priceLabel}`;

            chip.dataset.build = encodeURIComponent(JSON.stringify(build));
            chip.addEventListener("click", () => onBuildTap(chip));
            chip.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                onBuildTap(chip);
              }
            });
            row.appendChild(chip);
          });

          chat.appendChild(row);
          scrollChatToBottom();
        }

        // ðŸ§  BUILD DETAILS (when user taps a build chip)
        function onBuildTap(chip) {
          try {
            const bstr = decodeURIComponent(chip.dataset.build || "");
            const build = JSON.parse(bstr);

            const lines = [];

            const total = build.total_price || null;
            if (total) {
              const formattedTotal = `â‚±${Number(total).toLocaleString()}`;
              lines.push(`Estimated total: ${formattedTotal}`);
              lines.push("");
            }

            const componentOrder = [
              "cpu",
              "gpu",
              "motherboard",
              "ram",
              "storage",
              "psu",
            ];
            const seen = new Set();
            const formatLine = (label, name, price) =>
              `${label}: ${name}${price ? ` â€” ${price}` : ""}`;

            if (Array.isArray(build.chips) && build.chips.length) {
              build.chips.forEach((c) => {
                const type = (c.type || "").toLowerCase();
                const name = c.meta?.name || c.text || "";
                const price = c.meta?.price || c.price || "";
                if (componentOrder.includes(type) && !seen.has(type)) {
                  const label = type.charAt(0).toUpperCase() + type.slice(1);
                  lines.push(formatLine(label, name, price));
                  seen.add(type);
                }
              });
            } else {
              componentOrder.forEach((k) => {
                const item = build[k];
                if (item && (item.name || item.text)) {
                  const name = item.name || item.text;
                  const price = item.price || "";
                  lines.push(formatLine(k.toUpperCase(), name, price));
                }
              });
            }

            lines.push("");

            const wattChip = (build.chips || []).find((c) =>
              (c.id || "").startsWith("build-watt:")
            );
            const recoChip = (build.chips || []).find(
              (c) =>
                (c.type || "") === "psu-recommendation" ||
                (c.id || "").startsWith("build-psu-reco:")
            );

            if (wattChip) {
              const meta = wattChip.meta || {};
              const draw = meta.total_draw || wattChip.text || "";
              lines.push(`Estimated Draw: ${draw} W`);
            }

            if (recoChip) {
              const meta = recoChip.meta || {};
              const reco = meta.recommended_watt || recoChip.text || "";
              lines.push(`Recommended PSU: ${reco} W`);
            }

            const psuChips = (build.chips || []).filter(
              (c) => (c.type || "").toLowerCase() === "psu"
            );
            const uniquePSUs = [];
            const seenNames = new Set();

            psuChips.forEach((p) => {
              const name = p.meta?.name || p.text || "";
              if (!seenNames.has(name)) {
                seenNames.add(name);
                uniquePSUs.push({
                  name,
                  price: p.meta?.price || p.price || "",
                });
              }
            });

            if (uniquePSUs.length) {
              lines.push("");
              lines.push("Suggested PSUs:");
              uniquePSUs.forEach((p) => {
                lines.push(`â€¢ ${p.name}${p.price ? ` â€” ${p.price}` : ""}`);
              });
            }

            appendAssistant(lines.join("\n"));
          } catch (err) {
            console.error("Failed to render build:", err);
            appendAssistant("âš ï¸ Could not render build details properly.");
          }
        }

        // ðŸ’° Price formatter
        function formatPrice(p) {
          if (p === null || p === undefined || p === "") return "";
          if (typeof p === "string") {
            const trimmed = p.trim();
            if (trimmed.startsWith("â‚±")) return trimmed;
            const digits = trimmed.replace(/[^\d]/g, "");
            if (digits) return `â‚±${Number(digits).toLocaleString()}`;
            return trimmed;
          }
          return `â‚±${Number(p).toLocaleString()}`;
        }

        // ðŸ” COMPONENT LOOKUP (when user taps a chip)
        async function lookupChip(chipId) {
          appendAssistant("ðŸ” Checking details...");
          try {
            const res = await fetch(API_BASE + "/api/lookup", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ chip_id: chipId }),
            });

            const text = await res.text();

            if (!res.ok) {
              appendAssistant(
                `âš ï¸ Lookup failed (status ${res.status})\n\n${text}`
              );
              console.error("Lookup failed:", res.status, text);
              return;
            }

            let data;
            try {
              data = text ? JSON.parse(text) : {};
            } catch (err) {
              appendAssistant("âš ï¸ Lookup returned non-JSON. See console.");
              console.error("Failed to parse lookup JSON:", err, "raw:", text);
              appendAssistant(text);
              return;
            }

            const last = chat.querySelectorAll(".bubble-assistant");
            if (last.length) last[last.length - 1].remove();

            if (data.found) {
              let specs = "";
              for (const [key, val] of Object.entries(data.specs || {})) {
                specs += `${key}: ${val}\n`;
              }
              appendAssistant(
                `${data.name}\nPrice: ${data.price || "N/A"}\n${specs}`
              );
            } else {
              appendAssistant(data.error || "Component not found.");
            }
          } catch (err) {
            console.error(err);
            appendAssistant("Lookup failed (network).");
          }
        }

        // Starter suggestions (beginner-friendly tapables)
        function showStarterSuggestions() {
          appendAssistant("Welcome to ARIA");

          const starters = [
            "Recommend me a â‚±30000 PC build",
            "What CPU is compatible with RAMSTA RS-B450MP?",
            "Show me the specs of RTX 3060",
            "What does VRAM do?",
          ];

          const row = document.createElement("div");
          row.className = "chip-row";

          starters.forEach((text) => {
            const chip = document.createElement("div");
            chip.className = "chip";
            chip.tabIndex = 0;
            chip.setAttribute("role", "button");
            chip.textContent = text;
            chip.onclick = () => {
              qInput.value = text;
              setTimeout(() => ask(), 100);
            };
            chip.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                qInput.value = text;
                setTimeout(() => ask(), 100);
              }
            });
            row.appendChild(chip);
          });

          chat.appendChild(row);
          scrollChatToBottom();
        }

        // Prevent multiple concurrent requests
        let isRequestInFlight = false;

        // ðŸš€ MAIN â€” Send query to backend
        async function ask() {
          const query = qInput.value.trim();
          if (!query) return;
          if (isRequestInFlight) {
            return;
          }
          isRequestInFlight = true;
          sendBtn.disabled = true;
          qInput.disabled = true;

          appendUser(query);
          const thinking = appendAssistant("ARIA Thinking...");

          try {
            const res = await fetch(API_BASE + "/api/recommend", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ query }),
            });

            const text = await res.text();

            if (thinking && thinking.parentNode) thinking.remove();

            if (!res.ok) {
              appendAssistant(`âš ï¸ Server error ${res.status}\n\n${text}`);
              console.error("Server returned non-OK:", res.status, text);
              qInput.value = "";
              return;
            }

            let data = null;
            try {
              data = text ? JSON.parse(text) : {};
            } catch (err) {
              appendAssistant(
                "âš ï¸ Failed to parse server response as JSON. Showing raw response:"
              );
              console.error(
                "Failed to parse JSON from server response:",
                err,
                "raw:",
                text
              );
              appendAssistant(text);
              qInput.value = "";
              return;
            }

            // ðŸ§© Handle responses by source - FIXED COMPATIBILITY FORMAT
            if (data.source === "local-compatibility") {
              const verdict = data.verdict || "unknown";
              const emoji = data.emoji_verdict || "ðŸ”";
              const reason = data.reason || "";
              const target = data.target || "component";

              // Build clean compatibility message - FIXED FORMAT
              let compatMessage = `${emoji} COMPATIBILITY: ${verdict.toUpperCase()}\n\n`;
              compatMessage += `Component: ${target}\n\n`;

              if (reason) {
                compatMessage += `Technical Check: ${reason}\n\n`;
              }

              appendAssistant(compatMessage);

              // Show compatible options - FIXED: Only show chips if we have them
              const hasResults =
                Array.isArray(data.results) && data.results.length > 0;
              const hasChips =
                Array.isArray(data.chips) && data.chips.length > 0;

              if (hasResults || hasChips) {
                const optionsToShow = hasResults ? data.results : data.chips;
                appendAssistant("âœ… Compatible Options:");
                renderChips(
                  optionsToShow.slice(0, 8),
                  (c) => {
                    const id =
                      c.id ||
                      (c.type && (c.meta?.name || c.text)
                        ? `${c.type}:${(c.meta?.name || c.text)
                            .toLowerCase()
                            .replace(/\s+/g, "-")}`
                        : null);
                    if (id) return lookupChip(id);
                  },
                  "text",
                  true
                );
              }

              // If no results found
              if (!hasResults && !hasChips) {
                appendAssistant(
                  data.message ||
                    "âŒ No compatible components found. Please check specifications manually."
                );
              }
            } else if (data.source === "local-psu") {
              let textOut = `ðŸ”Œ PSU Recommendation\n`;
              textOut += `Detected: ${
                data.detected_str || "components unknown"
              }\n\n`;
              if (data.component_watts) {
                for (const [k, v] of Object.entries(data.component_watts)) {
                  textOut += `  ${k}: ${v} W\n`;
                }
                textOut += `\n`;
              }
              textOut += `Estimated total draw: ${data.total_draw} W\n`;
              textOut += `Recommended PSU (with headroom): ${data.recommended_psu} W\n\n`;

              if (
                Array.isArray(data.suggested_psu_chips) &&
                data.suggested_psu_chips.length
              ) {
                textOut += "Suggested PSUs:\n";
                data.suggested_psu_chips.forEach((chip) => {
                  const label =
                    chip.text || (chip.meta && chip.meta.name) || "PSU";
                  const price =
                    chip.price || (chip.meta && chip.meta.price) || "";
                  textOut += ` â€¢ ${label}${price ? ` â€” ${price}` : ""}\n`;
                });
                textOut += `\n(To inspect a PSU in detail, ask "show me specs of <PSU name>".)`;
              }

              appendAssistant(textOut);
            } else if (
              data.source === "local-recommendation" &&
              Array.isArray(data.results)
            ) {
              const normalized = data.results.map((r) => ({
                message: r.message || "",
                chips: r.chips || [],
                total_price: r.total_price || null,
                score: r.score || null,
                _orig: r,
              }));
              renderBuildRecommendations(normalized, 3);
            } else if (data.source === "local-list") {
              if (data.text) {
                appendAssistant(data.text);
              } else if (
                Array.isArray(data.results) &&
                data.results.length &&
                data.results.length <= 8
              ) {
                renderChips(
                  data.results,
                  (c) => {
                    const id = c.id || null;
                    if (id) lookupChip(id);
                  },
                  "text",
                  true
                );
              } else {
                appendAssistant("No items found.");
              }
            } else if (data.text) {
              appendAssistant(data.text);

              if (
                Array.isArray(data.results) &&
                data.results.length &&
                data.results.length <= 8
              ) {
                renderChips(
                  data.results,
                  (c) => {
                    const id =
                      c.id ||
                      (c.type && (c.meta?.name || c.text)
                        ? `${c.type}:${(c.meta?.name || c.text)
                            .toLowerCase()
                            .replace(/\s+/g, "-")}`
                        : null);
                    if (id) lookupChip(id);
                  },
                  "text",
                  true
                );
              }

              if (
                Array.isArray(data.chips) &&
                data.chips.length &&
                data.chips.length <= 8
              ) {
                renderChips(
                  data.chips,
                  (c) => {
                    if (c.id) lookupChip(c.id);
                  },
                  "text",
                  true
                );
              }
            } else {
              appendAssistant("No recommendations found. Server returned:");
              appendAssistant(JSON.stringify(data, null, 2));
            }
          } catch (err) {
            console.error("Network/fetch error:", err);
            appendAssistant(
              "âš ï¸ Connection error. Check Flask server. (See console for details)"
            );
          } finally {
            isRequestInFlight = false;
            sendBtn.disabled = false;
            qInput.disabled = false;
            qInput.value = "";
            qInput.focus();
          }
        }

        function autosizeTextarea(el) {
          if (!el) return;
          el.style.height = "auto";
          el.style.height = el.scrollHeight + "px";
        }

        autosizeTextarea(qInput);

        qInput.addEventListener("input", (e) => {
          autosizeTextarea(e.target);
        });

        sendBtn.addEventListener("click", ask);

        qInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            if (!e.shiftKey) {
              e.preventDefault();
              ask();
            } else {
            }
          }
        });

        // show starter suggestions when page loads
        window.addEventListener("load", showStarterSuggestions);
      })();
    </script>
  </body>
</html>
