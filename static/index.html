<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASK AI â€” PC Build Assistant</title>
    <style>
      :root {
        --teal: #007c89;
        --bg: #ffffff;
        --bubble: #e8edf1;
        --chip: #ffd7d0;
        --chip-text: #3b1f1f;
        --muted: #6b7280;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
      }
      body {
        background: #f1f3f4;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        padding: 16px;
      }
      .phone {
        background: var(--bg);
        width: 420px;
        max-width: 100%;
        height: 740px;
        max-height: 90vh;
        border-radius: 20px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .topbar {
        background: var(--teal);
        color: #fff;
        padding: 14px 18px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .topbar .icons {
        display: flex;
        gap: 10px;
      }
      .topbar button {
        background: transparent;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 16px;
      }
      .content {
        flex: 1;
        overflow-y: auto;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        scroll-behavior: smooth;
      }
      .bubble-assistant {
        align-self: flex-start;
        background: var(--bubble);
        color: #0a2026;
        padding: 14px 16px;
        border-radius: 16px;
        max-width: 95%;
        font-weight: 600;
        line-height: 1.4;
        word-wrap: break-word;
        white-space: pre-wrap;
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 6px;
      }
      .chip {
        background: var(--chip);
        color: var(--chip-text);
        padding: 10px 14px;
        border-radius: 999px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }
      .chip:hover {
        background: #ffc2b8;
        transform: scale(1.03);
      }
      .inputbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px;
        border-top: 1px solid #eee;
        background: #fff;
      }
      .pill {
        flex: 1;
        background: var(--chip);
        padding: 12px 16px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--chip-text);
        font-weight: 600;
      }
      .pill input {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        color: inherit;
        font-weight: 600;
      }
      .send-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: var(--teal);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
      }
      .send-btn:hover {
        background: #026b77;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .phone {
          width: 100%;
          height: calc(100vh - 20px);
          max-height: none;
          border-radius: 0;
        }
        .content {
          padding: 14px;
        }
        .bubble-assistant {
          max-width: 100%;
          font-size: 15px;
        }
        .chip {
          font-size: 14px;
          padding: 8px 12px;
        }
        .pill {
          padding: 10px 12px;
          font-size: 14px;
        }
        .send-btn {
          width: 40px;
          height: 40px;
          font-size: 18px;
        }
      }
    </style>
  </head>
  <body>
    <div class="phone">
      <div class="topbar">
        <div>ASK AI</div>
        <div class="icons">
          <button title="Back">âŸ²</button>
          <button title="Help">?</button>
        </div>
      </div>

      <div class="content" id="chat"></div>

      <div class="inputbar">
        <div class="pill">
          âœ¦ <input id="query" placeholder="e.g. recommend â‚±30000 build pc" />
        </div>
        <div class="send-btn" id="send">â–²</div>
      </div>
    </div>

    <script>
      // NOTE: use the real backend domain here so the static site calls the right API.
      const API_BASE = "https://arsemble-2025.onrender.com";
      const chat = document.getElementById("chat");
      const qInput = document.getElementById("query");
      const sendBtn = document.getElementById("send");

      // ðŸ§ USER MESSAGE
      function appendUser(text) {
        const wrapper = document.createElement("div");
        wrapper.style.alignSelf = "flex-end";
        wrapper.style.background = "#d0f0e0";
        wrapper.style.padding = "12px 16px";
        wrapper.style.borderRadius = "12px";
        wrapper.style.color = "#0a2026";
        wrapper.style.fontWeight = "600";
        wrapper.style.maxWidth = "80%";
        wrapper.style.wordWrap = "break-word";
        wrapper.textContent = text;
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
      }

      // ðŸ¤– ASSISTANT MESSAGE
      function appendAssistant(text) {
        const wrapper = document.createElement("div");
        wrapper.className = "bubble-assistant";
        wrapper.style.whiteSpace = "pre-wrap";
        wrapper.textContent = text || "";
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
        return wrapper;
      }

      // Generic chip renderer
      function renderChips(
        items = [],
        onClickFn = null,
        labelKey = "text",
        showPrice = true
      ) {
        if (!Array.isArray(items) || items.length === 0) return;
        const row = document.createElement("div");
        row.className = "chip-row";
        items.forEach((c) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          const text =
            typeof c === "string"
              ? c
              : c[labelKey] ||
                (c.meta && c.meta.name) ||
                c.text ||
                c.id ||
                c.name ||
                "Unknown";
          const priceVal =
            c && (c.price || (c.meta && c.meta.price))
              ? c.price || c.meta.price
              : "";
          const price = priceVal ? ` â€” ${priceVal}` : "";
          chip.textContent = showPrice ? `${text}${price}` : text;
          if (c && c.id) chip.dataset.chipid = c.id;
          chip.addEventListener("click", (ev) => {
            try {
              if (typeof onClickFn === "function") return onClickFn(c, ev);
              const explicitId = c && (c.id || chip.dataset.chipid);
              if (explicitId) return lookupChip(explicitId);
              if (c && chip.dataset && chip.dataset.build)
                return onBuildTap(chip);
              if (c && c.meta && c.meta.name && c.type) {
                const id = `${c.type}:${(c.meta.name || "")
                  .toLowerCase()
                  .replace(/\s+/g, "-")}`;
                return lookupChip(id);
              }
              if (c && c.type && text) {
                const id = `${c.type}:${text
                  .toLowerCase()
                  .replace(/\s+/g, "-")}`;
                return lookupChip(id);
              }
            } catch (err) {
              console.error("Chip click handler error:", err);
            }
          });
          row.appendChild(chip);
        });
        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // Build recommendation cards
      function renderBuildRecommendations(results, maxBuilds = 3) {
        appendAssistant(`Here are some recommended builds you can explore:`);
        const row = document.createElement("div");
        row.className = "chip-row";
        results.slice(0, maxBuilds).forEach((build, idx) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          const price = build.total_price || null;
          const priceLabel = price ? ` â€” ${formatPrice(price)}` : "";
          chip.textContent = `Build ${idx + 1}${priceLabel}`;
          chip.dataset.build = encodeURIComponent(JSON.stringify(build));
          chip.addEventListener("click", () => onBuildTap(chip));
          row.appendChild(chip);
        });
        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // Compatibility renderer
      function renderCompatibility(data) {
        if (data.results && data.results.length) {
          let out = `The ${data.target} is compatible with these ${(
            data.compatible_type || "component"
          ).toUpperCase()}s:\n\n`;
          data.results.slice(0, 12).forEach((c) => {
            const price = c.price || (c.meta && c.meta.price) || "";
            out += `- ${c.text}${price ? ` (${price})` : ""}\n`;
          });
          appendAssistant(out);
        } else {
          appendAssistant(data.message || "No compatible components found.");
        }
      }

      // Build details when tapping a build chip
      function onBuildTap(chip) {
        try {
          const bstr = decodeURIComponent(chip.dataset.build || "");
          const build = JSON.parse(bstr);
          const lines = [];
          const total = build.total_price || null;
          if (total) {
            const formattedTotal = `â‚±${Number(total).toLocaleString()}`;
            lines.push(`Estimated total: ${formattedTotal}`);
            lines.push("");
          }
          const componentOrder = [
            "cpu",
            "gpu",
            "motherboard",
            "ram",
            "storage",
            "psu",
          ];
          const seen = new Set();
          const formatLine = (label, name, price) =>
            `${label}: ${name}${price ? ` â€” ${price}` : ""}`;
          if (Array.isArray(build.chips) && build.chips.length) {
            build.chips.forEach((c) => {
              const type = (c.type || "").toLowerCase();
              const name = c.meta?.name || c.text || "";
              const price = c.meta?.price || c.price || "";
              if (componentOrder.includes(type) && !seen.has(type)) {
                const label = type.charAt(0).toUpperCase() + type.slice(1);
                lines.push(formatLine(label, name, price));
                seen.add(type);
              }
            });
          } else {
            componentOrder.forEach((k) => {
              const item = build[k];
              if (item && (item.name || item.text)) {
                const name = item.name || item.text;
                const price = item.price || "";
                lines.push(formatLine(k.toUpperCase(), name, price));
              }
            });
          }
          lines.push("");
          const wattChip = (build.chips || []).find((c) =>
            (c.id || "").startsWith("build-watt:")
          );
          const recoChip = (build.chips || []).find(
            (c) =>
              (c.type || "") === "psu-recommendation" ||
              (c.id || "").startsWith("build-psu-reco:")
          );
          if (wattChip) {
            const meta = wattChip.meta || {};
            const draw = meta.total_draw || wattChip.text || "";
            lines.push(`Estimated Draw: ${draw} W`);
          }
          if (recoChip) {
            const meta = recoChip.meta || {};
            const reco = meta.recommended_watt || recoChip.text || "";
            lines.push(`Recommended PSU: ${reco} W`);
          }
          const psuChips = (build.chips || []).filter(
            (c) => (c.type || "").toLowerCase() === "psu"
          );
          const uniquePSUs = [];
          const seenNames = new Set();
          psuChips.forEach((p) => {
            const name = p.meta?.name || p.text || "";
            if (!seenNames.has(name)) {
              seenNames.add(name);
              uniquePSUs.push({ name, price: p.meta?.price || p.price || "" });
            }
          });
          if (uniquePSUs.length) {
            lines.push("");
            lines.push("Suggested PSUs:");
            uniquePSUs.forEach((p) => {
              lines.push(`â€¢ ${p.name}${p.price ? ` â€” ${p.price}` : ""}`);
            });
          }
          appendAssistant(lines.join("\n"));
        } catch (err) {
          console.error("Failed to render build:", err);
          appendAssistant("âš ï¸ Could not render build details properly.");
        }
      }

      // Price formatter
      function formatPrice(p) {
        if (p === null || p === undefined || p === "") return "";
        if (typeof p === "string") {
          const trimmed = p.trim();
          if (trimmed.startsWith("â‚±")) return trimmed;
          const digits = trimmed.replace(/[^\d]/g, "");
          if (digits) return `â‚±${Number(digits).toLocaleString()}`;
          return trimmed;
        }
        return `â‚±${Number(p).toLocaleString()}`;
      }

      // Component lookup
      async function lookupChip(chipId) {
        appendAssistant("ðŸ” Checking details...");
        try {
          const res = await fetch(API_BASE + "/api/lookup", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ chip_id: chipId }),
          });
          const text = await res.text();
          if (!res.ok) {
            appendAssistant(
              `âš ï¸ Lookup failed (status ${res.status})\n\n${text}`
            );
            console.error("Lookup failed:", res.status, text);
            return;
          }
          let data;
          try {
            data = text ? JSON.parse(text) : {};
          } catch (err) {
            appendAssistant("âš ï¸ Lookup returned non-JSON. See console.");
            console.error("Failed to parse lookup JSON:", err, "raw:", text);
            appendAssistant(text);
            return;
          }
          const last = chat.querySelectorAll(".bubble-assistant");
          if (last.length) last[last.length - 1].remove();
          if (data.found) {
            let specs = "";
            for (const [key, val] of Object.entries(data.specs || {}))
              specs += `${key}: ${val}\n`;
            appendAssistant(`${data.name}\nPrice: ${data.price}\n${specs}`);
          } else appendAssistant("Component not found.");
        } catch (err) {
          console.error(err);
          appendAssistant("Lookup failed (network).");
        }
      }

      // Starter suggestions (now use streamPrompt)
      function showStarterSuggestions() {
        appendAssistant("Welcome to ARIA");
        const starters = [
          "Recommend me a â‚±30000 PC build",
          "What CPU is compatible with RAMSTA RS-B450MP?",
          "Show me the specs of RTX 3060",
          "What does VRAM do?",
        ];
        const row = document.createElement("div");
        row.className = "chip-row";
        starters.forEach((text) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.textContent = text;
          chip.onclick = () => {
            qInput.value = text;
            setTimeout(() => streamPrompt(text), 100);
          };
          row.appendChild(chip);
        });
        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // Non-streaming fallback request (keeps backward compatibility)
      async function ask() {
        const query = qInput.value.trim();
        if (!query) return;
        appendUser(query);
        const thinking = appendAssistant("ARIA Thinking...");
        try {
          const res = await fetch(API_BASE + "/api/recommend", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ query }),
          });
          const text = await res.text();
          if (thinking && thinking.parentNode) thinking.remove();
          if (!res.ok) {
            appendAssistant(`âš ï¸ Server error ${res.status}\n\n${text}`);
            qInput.value = "";
            return;
          }
          let data = null;
          try {
            data = text ? JSON.parse(text) : {};
          } catch (err) {
            appendAssistant(
              "âš ï¸ Failed to parse server response as JSON. Showing raw response:"
            );
            appendAssistant(text);
            qInput.value = "";
            return;
          }

          // Quick fallback: if no structured results but backend returned plain text, show it
          if ((!data.results || data.results.length === 0) && data.text) {
            appendAssistant(data.text);
            qInput.value = "";
            return;
          }

          if (data.source === "local-compatibility") {
            if (Array.isArray(data.results) && data.results.length) {
              appendAssistant(
                `The ${data.target} is compatible with these ${(
                  data.compatible_type || "component"
                ).toUpperCase()} options â€” tap any item to view specs:`
              );
              const chipsToShow = data.results.slice(0, 12);
              renderChips(
                chipsToShow,
                (c) => {
                  const id =
                    c.id ||
                    (c.type && (c.meta?.name || c.text)
                      ? `${c.type}:${(c.meta?.name || c.text)
                          .toLowerCase()
                          .replace(/\s+/g, "-")}`
                      : null);
                  if (id) return lookupChip(id);
                },
                "text",
                true
              );
            } else
              appendAssistant(
                data.message || "No compatible components found."
              );
          } else if (data.source === "local-psu") {
            let textOut = `ðŸ”Œ PSU Recommendation\n`;
            textOut += `Detected: ${
              data.detected_str || "components unknown"
            }\n\n`;
            if (data.component_watts)
              for (const [k, v] of Object.entries(data.component_watts))
                textOut += `  ${k}: ${v} W\n`;
            textOut += `\nEstimated total draw: ${data.total_draw} W\nRecommended PSU (with headroom): ${data.recommended_psu} W\n\n`;
            if (
              Array.isArray(data.suggested_psu_chips) &&
              data.suggested_psu_chips.length
            ) {
              textOut += "Suggested PSUs:\n";
              data.suggested_psu_chips.forEach((chip) => {
                const label =
                  chip.text || (chip.meta && chip.meta.name) || "PSU";
                const price =
                  chip.price || (chip.meta && chip.meta.price) || "";
                textOut += ` â€¢ ${label}${price ? ` â€” ${price}` : ""}\n`;
              });
            }
            appendAssistant(textOut);
          } else if (
            data.source === "local-recommendation" &&
            Array.isArray(data.results)
          ) {
            const normalized = data.results.map((r) => ({
              message: r.message || "",
              chips: r.chips || [],
              total_price: r.total_price || null,
              score: r.score || null,
              _orig: r,
            }));
            renderBuildRecommendations(normalized, 3);
          } else if (data.source === "local-list") {
            if (data.text) appendAssistant(data.text);
            else if (
              Array.isArray(data.results) &&
              data.results.length &&
              data.results.length <= 8
            )
              renderChips(
                data.results,
                (c) => {
                  const id = c.id || null;
                  if (id) lookupChip(id);
                },
                "text",
                true
              );
            else appendAssistant("No items found.");
          } else if (data.text) {
            appendAssistant(data.text);
            if (
              Array.isArray(data.results) &&
              data.results.length &&
              data.results.length <= 8
            ) {
              renderChips(
                data.results,
                (c) => {
                  const id =
                    c.id ||
                    (c.type && (c.meta?.name || c.text)
                      ? `${c.type}:${(c.meta?.name || c.text)
                          .toLowerCase()
                          .replace(/\s+/g, "-")}`
                      : null);
                  if (id) lookupChip(id);
                },
                "text",
                true
              );
            }
            if (
              Array.isArray(data.chips) &&
              data.chips.length &&
              data.chips.length <= 8
            ) {
              renderChips(
                data.chips,
                (c) => {
                  if (c.id) lookupChip(c.id);
                },
                "text",
                true
              );
            }
          } else {
            appendAssistant("No recommendations found. Server returned:");
            appendAssistant(JSON.stringify(data, null, 2));
          }
        } catch (err) {
          console.error("Network/fetch error:", err);
          if (thinking && thinking.parentNode) thinking.remove();
          appendAssistant(
            "âš ï¸ Connection error. Check Flask server. (See console for details)"
          );
        } finally {
          qInput.value = "";
        }
      }

      // === NEW: streaming function that appends into assistant bubble ===
      async function streamPrompt(prompt) {
        if (!prompt || !prompt.trim()) return;
        appendUser(prompt);
        const assistantEl = appendAssistant(""); // will fill progressively
        setTimeout(() => {
          chat.scrollTop = chat.scrollHeight;
        }, 50);
        try {
          const resp = await fetch(API_BASE + "/api/ai/stream", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt }),
          });
          if (!resp.ok) {
            assistantEl.textContent = `Error ${resp.status}: ${resp.statusText}`;
            return;
          }
          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let firstChunk = true;
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop();
            for (const line of lines) {
              if (!line.trim()) continue;
              try {
                const obj = JSON.parse(line);
                if (obj.text !== undefined) assistantEl.textContent += obj.text;
                else if (typeof obj === "string")
                  assistantEl.textContent += obj;
                else assistantEl.textContent += JSON.stringify(obj);
              } catch (err) {
                assistantEl.textContent += line;
              }
              if (firstChunk) {
                document.title = "first-chunk";
                firstChunk = false;
              }
              chat.scrollTop = chat.scrollHeight;
            }
          }
          if (buffer.trim()) {
            try {
              const obj = JSON.parse(buffer);
              if (obj.text !== undefined) assistantEl.textContent += obj.text;
              else assistantEl.textContent += JSON.stringify(obj);
            } catch (err) {
              assistantEl.textContent += buffer;
            }
          }
        } catch (err) {
          console.error("Stream error:", err);
          assistantEl.textContent += `\n\n[Network error: ${
            err.message || err
          }]`;
        } finally {
          setTimeout(() => {
            if (document.title === "first-chunk") document.title = "ASK AI";
          }, 1200);
          chat.scrollTop = chat.scrollHeight;
        }
      }

      // Wire send button to streaming. If you want fallback non-streaming, call ask() instead.
      sendBtn.onclick = () => {
        const q = qInput.value.trim();
        if (!q) return;
        // Choose streaming by default:
        streamPrompt(q);
        qInput.value = "";
      };

      qInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          sendBtn.click();
        }
      });

      // show starter suggestions when page loads
      window.addEventListener("load", showStarterSuggestions);
    </script>
  </body>
</html>
