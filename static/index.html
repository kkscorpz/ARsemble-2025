<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASK AI â€” PC Build Assistant</title>
    <style>
      :root {
        --teal: #007c89;
        --bg: #ffffff;
        --bubble: #e8edf1;
        --chip: #ffd7d0;
        --chip-text: #3b1f1f;
        --muted: #6b7280;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
      }
      body {
        background: #f1f3f4;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        padding: 16px;
      }
      .phone {
        background: var(--bg);
        width: 420px;
        max-width: 100%;
        height: 740px;
        max-height: 90vh;
        border-radius: 20px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .topbar {
        background: var(--teal);
        color: #fff;
        padding: 14px 18px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .topbar .icons {
        display: flex;
        gap: 10px;
      }
      .topbar button {
        background: transparent;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 16px;
      }
      .content {
        flex: 1;
        overflow-y: auto;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        scroll-behavior: smooth;
      }
      .bubble-assistant {
        align-self: flex-start;
        background: var(--bubble);
        color: #0a2026;
        padding: 14px 16px;
        border-radius: 16px;
        max-width: 95%;
        font-weight: 600;
        line-height: 1.4;
        word-wrap: break-word;
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 6px;
      }
      .chip {
        background: var(--chip);
        color: var(--chip-text);
        padding: 10px 14px;
        border-radius: 999px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }
      .chip:hover {
        background: #ffc2b8;
        transform: scale(1.03);
      }
      .inputbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px;
        border-top: 1px solid #eee;
        background: #fff;
      }
      .pill {
        flex: 1;
        background: var(--chip);
        padding: 12px 16px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--chip-text);
        font-weight: 600;
      }
      .pill input {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        color: inherit;
        font-weight: 600;
      }
      .send-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: var(--teal);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
      }
      .send-btn:hover {
        background: #026b77;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .phone {
          width: 100%;
          height: calc(100vh - 20px);
          max-height: none;
          border-radius: 0;
        }
        .content {
          padding: 14px;
        }
        .bubble-assistant {
          max-width: 100%;
          font-size: 15px;
        }
        .chip {
          font-size: 14px;
          padding: 8px 12px;
        }
        .pill {
          padding: 10px 12px;
          font-size: 14px;
        }
        .send-btn {
          width: 40px;
          height: 40px;
          font-size: 18px;
        }
      }
    </style>
  </head>
  <body>
    <div class="phone">
      <div class="topbar">
        <div>ASK AI</div>
        <div class="icons">
          <button title="Back">âŸ²</button>
          <button title="Help">?</button>
        </div>
      </div>

      <div class="content" id="chat"></div>

      <div class="inputbar">
        <div class="pill">
          âœ¦ <input id="query" placeholder="e.g. recommend â‚±30000 build pc" />
        </div>
        <div class="send-btn" id="send">â–²</div>
      </div>
    </div>

    <script>
      // Use the same origin as the page to avoid origin mismatches
      const API_BASE = window.location.origin;
      const chat = document.getElementById("chat");
      const qInput = document.getElementById("query");
      const sendBtn = document.getElementById("send");

      // ðŸ§ USER MESSAGE
      function appendUser(text) {
        const wrapper = document.createElement("div");
        wrapper.style.alignSelf = "flex-end";
        wrapper.style.background = "#d0f0e0";
        wrapper.style.padding = "12px 16px";
        wrapper.style.borderRadius = "12px";
        wrapper.style.color = "#0a2026";
        wrapper.style.fontWeight = "600";
        wrapper.style.maxWidth = "80%";
        wrapper.style.wordWrap = "break-word";
        wrapper.textContent = text;
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
      }

      // ðŸ¤– ASSISTANT MESSAGE
      function appendAssistant(text) {
        const wrapper = document.createElement("div");
        wrapper.className = "bubble-assistant";
        wrapper.style.whiteSpace = "pre-wrap";
        wrapper.textContent = text;
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
        return wrapper;
      }

      // ðŸ’¸ BUILD RECOMMENDATIONS (Tapable)
      function renderBuildRecommendations(results, maxBuilds = 3) {
        appendAssistant(`Here are some recommended builds you can explore:`);

        const row = document.createElement("div");
        row.className = "chip-row";

        results.slice(0, maxBuilds).forEach((build, idx) => {
          const chip = document.createElement("div");
          chip.className = "chip";

          // Use only total_price as canonical price (avoid watt numbers)
          const price = build.total_price || null;
          const priceLabel = price ? ` â€” ${formatPrice(price)}` : "";
          chip.textContent = `Build ${idx + 1}${priceLabel}`;

          chip.dataset.build = encodeURIComponent(JSON.stringify(build));
          chip.addEventListener("click", () => onBuildTap(chip));
          row.appendChild(chip);
        });

        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // âš™ï¸ COMPATIBILITY RECOMMENDATIONS (Tapable)
      function renderCompatibility(data) {
        if (data.results && data.results.length) {
          appendAssistant(
            `The ${
              data.target
            } is compatible with these ${data.compatible_type.toUpperCase()}s:`
          );
          const row = document.createElement("div");
          row.className = "chip-row";

          data.results.forEach((c) => {
            const chip = document.createElement("div");
            chip.className = "chip";
            chip.textContent = `${c.text}${c.price ? ` (${c.price})` : ""}`;
            chip.onclick = () =>
              lookupChip(
                `${c.type}:${(c.meta?.name || c.text)
                  .toLowerCase()
                  .replace(/\s+/g, "-")}`
              );
            row.appendChild(chip);
          });

          chat.appendChild(row);
          chat.scrollTop = chat.scrollHeight;
        } else {
          appendAssistant(data.message || "No compatible components found.");
        }
      }

      // ðŸ§  BUILD DETAILS (when user taps a build chip)
      function onBuildTap(chip) {
        try {
          const bstr = decodeURIComponent(chip.dataset.build || "");
          const build = JSON.parse(bstr);

          const lines = [];

          // --- Header (use total_price only)
          const total = build.total_price || null;
          const score = build.score ?? null;
          if (total || score !== null) {
            const formattedTotal = total
              ? `â‚±${Number(total).toLocaleString()}`
              : "";
            const scorePart = score !== null ? ` â€” Score ${score}` : "";
            lines.push(`Estimated total: ${formattedTotal}${scorePart}`);
            lines.push(""); // blank line
          }

          // --- Component listing
          const componentOrder = [
            "cpu",
            "gpu",
            "motherboard",
            "ram",
            "storage",
            "psu",
          ];
          const seen = new Set();
          const formatLine = (label, name, price) =>
            `${label}: ${name}${price ? ` â€” ${price}` : ""}`;

          if (Array.isArray(build.chips) && build.chips.length) {
            // prefer chips.meta.name & meta.price when available
            build.chips.forEach((c) => {
              const type = (c.type || "").toLowerCase();
              const name = c.meta?.name || c.text || "";
              const price = c.meta?.price || c.price || "";
              if (componentOrder.includes(type) && !seen.has(type)) {
                const label = type.charAt(0).toUpperCase() + type.slice(1);
                lines.push(formatLine(label, name, price));
                seen.add(type);
              }
            });
          } else {
            // fallback: try build fields
            componentOrder.forEach((k) => {
              const item = build[k];
              if (item && (item.name || item.text)) {
                const name = item.name || item.text;
                const price = item.price || "";
                lines.push(formatLine(k.toUpperCase(), name, price));
              }
            });
          }

          lines.push(""); // spacing

          // --- Wattage and Recommendation
          const wattChip = (build.chips || []).find((c) =>
            (c.id || "").startsWith("build-watt:")
          );
          const recoChip = (build.chips || []).find(
            (c) =>
              (c.type || "") === "psu-recommendation" ||
              (c.id || "").startsWith("build-psu-reco:")
          );

          if (wattChip) {
            const meta = wattChip.meta || {};
            const draw = meta.total_draw || wattChip.text || "";
            lines.push(`Estimated Draw: ${draw} W`);
          }

          if (recoChip) {
            const meta = recoChip.meta || {};
            const reco = meta.recommended_watt || recoChip.text || "";
            lines.push(`Recommended PSU: ${reco} W`);
          }

          // --- Suggested PSUs (deduped)
          const psuChips = (build.chips || []).filter(
            (c) => (c.type || "").toLowerCase() === "psu"
          );
          const uniquePSUs = [];
          const seenNames = new Set();

          psuChips.forEach((p) => {
            const name = p.meta?.name || p.text || "";
            if (!seenNames.has(name)) {
              seenNames.add(name);
              uniquePSUs.push({
                name,
                price: p.meta?.price || p.price || "",
              });
            }
          });

          if (uniquePSUs.length) {
            lines.push("");
            lines.push("Suggested PSUs:");
            uniquePSUs.forEach((p) => {
              lines.push(`â€¢ ${p.name}${p.price ? ` â€” ${p.price}` : ""}`);
            });
          }

          appendAssistant(lines.join("\n"));
        } catch (err) {
          console.error("Failed to render build:", err);
          appendAssistant("âš ï¸ Could not render build details properly.");
        }
      }

      // ðŸ’° Price formatter
      function formatPrice(p) {
        if (p === null || p === undefined || p === "") return "";
        // keep strings that already have currency symbol
        if (typeof p === "string") {
          const trimmed = p.trim();
          if (trimmed.startsWith("â‚±")) return trimmed;
          // try to extract digits and format
          const digits = trimmed.replace(/[^\d]/g, "");
          if (digits) return `â‚±${Number(digits).toLocaleString()}`;
          return trimmed;
        }
        return `â‚±${Number(p).toLocaleString()}`;
      }

      // ðŸ” COMPONENT LOOKUP (when user taps a chip)
      async function lookupChip(chipId) {
        appendAssistant("ðŸ” Checking details...");
        try {
          const res = await fetch(API_BASE + "/api/lookup", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ chip_id: chipId }),
          });

          const text = await res.text();
          if (!res.ok) {
            appendAssistant(
              `âš ï¸ Lookup failed (status ${res.status})\n\n${text}`
            );
            console.error("Lookup failed:", res.status, text);
            return;
          }

          let data;
          try {
            data = text ? JSON.parse(text) : {};
          } catch (err) {
            appendAssistant("âš ï¸ Lookup returned non-JSON. See console.");
            console.error("Failed to parse lookup JSON:", err, "raw:", text);
            appendAssistant(text);
            return;
          }

          // remove the temporary "Checking details..." bubble
          const last = chat.querySelectorAll(".bubble-assistant");
          if (last.length) last[last.length - 1].remove();

          if (data.found) {
            let specs = "";
            for (const [key, val] of Object.entries(data.specs || {})) {
              specs += `${key}: ${val}\n`;
            }
            appendAssistant(`${data.name}\nPrice: ${data.price}\n${specs}`);
          } else {
            appendAssistant("Component not found.");
          }
        } catch (err) {
          console.error(err);
          appendAssistant("Lookup failed (network).");
        }
      }

      // Starter suggestions (beginner-friendly tapables)
      function showStarterSuggestions() {
        appendAssistant(
          "ðŸ‘‹ Welcome to ARsemble AI â€” your PC-building buddy!\nTap a suggestion to get started."
        );

        const starters = [
          "Recommend me a â‚±30000 PC build",
          "What CPU is compatible with RAMSTA RS-B450MP?",
          "Show me the specs of RTX 3060",
          "What does VRAM do?",
          "How much power do I need for my build?",
        ];

        const row = document.createElement("div");
        row.className = "chip-row";

        starters.forEach((text) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.textContent = text;
          chip.onclick = () => {
            qInput.value = text;
            setTimeout(() => ask(), 100);
          };
          row.appendChild(chip);
        });

        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // ðŸš€ MAIN â€” Send query to backend (robust, shows server body for debugging)
      async function ask() {
        const query = qInput.value.trim();
        if (!query) return;

        appendUser(query);
        const thinking = appendAssistant("ðŸ’­ Thinking...");

        try {
          const res = await fetch(API_BASE + "/api/recommend", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ query }),
          });

          // Read raw text first so we can show helpful debug info if parsing fails
          const text = await res.text();

          // remove thinking bubble
          if (thinking && thinking.parentNode) thinking.remove();

          if (!res.ok) {
            appendAssistant(`âš ï¸ Server error ${res.status}\n\n${text}`);
            console.error("Server returned non-OK:", res.status, text);
            qInput.value = "";
            return;
          }

          let data = null;
          try {
            data = text ? JSON.parse(text) : {};
          } catch (err) {
            appendAssistant(
              "âš ï¸ Failed to parse server response as JSON. Showing raw response:"
            );
            console.error(
              "Failed to parse JSON from server response:",
              err,
              "raw:",
              text
            );
            appendAssistant(text);
            qInput.value = "";
            return;
          }

          // ðŸ§© Handle compatibility
          if (data.source === "local-compatibility") {
            renderCompatibility(data);
          }
          // âš¡ Handle PSU responses
          else if (data.source === "local-psu") {
            let text = `ðŸ”Œ PSU Recommendation\n`;
            text += `Detected: ${
              data.detected_str || "components unknown"
            }\n\n`;
            // show per-component watts if present
            if (data.component_watts) {
              for (const [k, v] of Object.entries(data.component_watts)) {
                text += `  ${k}: ${v} W\n`;
              }
              text += `\n`;
            }
            text += `Estimated total draw: ${data.total_draw} W\n`;
            text += `Recommended PSU (with headroom): ${data.recommended_psu} W\n`;
            appendAssistant(text);

            // suggested PSU chips
            if (
              Array.isArray(data.suggested_psu_chips) &&
              data.suggested_psu_chips.length
            ) {
              const row = document.createElement("div");
              row.className = "chip-row";
              data.suggested_psu_chips.forEach((chip) => {
                const c = document.createElement("div");
                c.className = "chip";
                c.textContent = `${chip.text}${
                  chip.price ? ` â€” ${chip.price}` : ""
                }`;
                c.onclick = () => lookupChip(chip.id);
                row.appendChild(c);
              });
              chat.appendChild(row);
            }

            // recommended chip display
          }
          // ðŸ’¸ Handle budget builds
          else if (
            data.source === "local-recommendation" &&
            Array.isArray(data.results)
          ) {
            const normalized = data.results.map((r) => ({
              message: r.message || "",
              chips: r.chips || [],
              total_price: r.total_price || null,
              score: r.score || null,
            }));
            renderBuildRecommendations(normalized, 3);
          }
          // ðŸ¤– Handle Gemini text answers
          else if (data.text) {
            appendAssistant(data.text);
          } else {
            appendAssistant("No recommendations found. Server returned:");
            appendAssistant(JSON.stringify(data, null, 2));
          }
        } catch (err) {
          console.error("Network/fetch error:", err);
          if (thinking && thinking.parentNode) thinking.remove();
          appendAssistant(
            "âš ï¸ Connection error. Check Flask server. (See console for details)"
          );
        } finally {
          qInput.value = "";
        }
      }

      // âŒ¨ï¸ UI wiring
      sendBtn.onclick = ask;
      qInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") ask();
      });

      // show starter suggestions when page loads
      window.addEventListener("load", showStarterSuggestions);
    </script>
  </body>
</html>
