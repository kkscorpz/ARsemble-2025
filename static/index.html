<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ASK AI â€” PC Build Assistant</title>
    <style>
      :root {
        --teal: #007c89;
        --bg: #ffffff;
        --bubble: #e8edf1;
        --chip: #ffd7d0;
        --chip-text: #3b1f1f;
        --muted: #6b7280;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
      }
      body {
        background: #f1f3f4;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        padding: 16px;
      }
      .phone {
        background: var(--bg);
        width: 420px;
        max-width: 100%;
        height: 740px;
        max-height: 90vh;
        border-radius: 20px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .topbar {
        background: var(--teal);
        color: #fff;
        padding: 14px 18px;
        font-weight: 700;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .topbar .icons {
        display: flex;
        gap: 10px;
      }
      .topbar button {
        background: transparent;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 16px;
      }
      .content {
        flex: 1;
        overflow-y: auto;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        scroll-behavior: smooth;
      }
      .bubble-assistant {
        align-self: flex-start;
        background: var(--bubble);
        color: #0a2026;
        padding: 14px 16px;
        border-radius: 16px;
        max-width: 95%;
        font-weight: 600;
        line-height: 1.4;
        word-wrap: break-word;
      }
      .chip-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 6px;
      }
      .chip {
        background: var(--chip);
        color: var(--chip-text);
        padding: 10px 14px;
        border-radius: 999px;
        font-weight: 700;
        cursor: pointer;
        transition: background 0.2s, transform 0.2s;
      }
      .chip:hover {
        background: #ffc2b8;
        transform: scale(1.03);
      }
      .inputbar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px;
        border-top: 1px solid #eee;
        background: #fff;
      }
      .pill {
        flex: 1;
        background: var(--chip);
        padding: 12px 16px;
        border-radius: 999px;
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--chip-text);
        font-weight: 600;
      }
      .pill input {
        flex: 1;
        border: none;
        background: transparent;
        outline: none;
        color: inherit;
        font-weight: 600;
      }
      .send-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: var(--teal);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
      }
      .send-btn:hover {
        background: #026b77;
      }

      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .phone {
          width: 100%;
          height: calc(100vh - 20px);
          max-height: none;
          border-radius: 0;
        }
        .content {
          padding: 14px;
        }
        .bubble-assistant {
          max-width: 100%;
          font-size: 15px;
        }
        .chip {
          font-size: 14px;
          padding: 8px 12px;
        }
        .pill {
          padding: 10px 12px;
          font-size: 14px;
        }
        .send-btn {
          width: 40px;
          height: 40px;
          font-size: 18px;
        }
      }
    </style>
  </head>
  <body>
    <div class="phone">
      <div class="topbar">
        <div>ASK AI</div>
        <div class="icons">
          <button title="Back">âŸ²</button>
          <button title="Help">?</button>
        </div>
      </div>

      <div class="content" id="chat"></div>

      <div class="inputbar">
        <div class="pill">
          âœ¦ <input id="query" placeholder="e.g. recommend â‚±30000 build pc" />
        </div>
        <div class="send-btn" id="send">â–²</div>
      </div>
    </div>

    <script>
      // Use the same origin as the page to avoid origin mismatches
      const API_BASE = window.location.origin;
      const chat = document.getElementById("chat");
      const qInput = document.getElementById("query");
      const sendBtn = document.getElementById("send");

      // ðŸ§ USER MESSAGE
      function appendUser(text) {
        const wrapper = document.createElement("div");
        wrapper.style.alignSelf = "flex-end";
        wrapper.style.background = "#d0f0e0";
        wrapper.style.padding = "12px 16px";
        wrapper.style.borderRadius = "12px";
        wrapper.style.color = "#0a2026";
        wrapper.style.fontWeight = "600";
        wrapper.style.maxWidth = "80%";
        wrapper.style.wordWrap = "break-word";
        wrapper.textContent = text;
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
      }

      // ðŸ¤– ASSISTANT MESSAGE
      function appendAssistant(text) {
        const wrapper = document.createElement("div");
        wrapper.className = "bubble-assistant";
        wrapper.style.whiteSpace = "pre-wrap";
        wrapper.textContent = text;
        chat.appendChild(wrapper);
        chat.scrollTop = chat.scrollHeight;
        return wrapper;
      }

      // Generic chip renderer used by multiple handlers (kept for starter chips / small sets)
      function renderChips(
        items = [],
        onClickFn = null,
        labelKey = "text",
        showPrice = true
      ) {
        if (!Array.isArray(items) || items.length === 0) return;
        const row = document.createElement("div");
        row.className = "chip-row";

        items.forEach((c) => {
          const chip = document.createElement("div");
          chip.className = "chip";

          // Items may be "chip" objects or build objects â€” try to be flexible
          const text =
            typeof c === "string"
              ? c
              : c[labelKey] ||
                (c.meta && c.meta.name) ||
                c.text ||
                c.id ||
                c.name ||
                "Unknown";

          const priceVal =
            c && (c.price || (c.meta && c.meta.price))
              ? c.price || c.meta.price
              : "";
          const price = priceVal ? ` â€” ${priceVal}` : "";

          chip.textContent = showPrice ? `${text}${price}` : text;

          // attach id if present for lookupChip (dataset is easiest to pick up)
          if (c && c.id) chip.dataset.chipid = c.id;

          chip.addEventListener("click", (ev) => {
            try {
              if (typeof onClickFn === "function") return onClickFn(c, ev);

              // default behaviour: if chip has id -> lookupChip
              const explicitId = c && (c.id || chip.dataset.chipid);
              if (explicitId) return lookupChip(explicitId);

              // if chip is a build-like object and contains encoded build payload, try triggering onBuildTap
              if (c && chip.dataset && chip.dataset.build)
                return onBuildTap(chip);

              // fallback: if object contains meta.name + type, try lookup by constructed id
              if (c && c.meta && c.meta.name && c.type) {
                const id = `${c.type}:${(c.meta.name || "")
                  .toLowerCase()
                  .replace(/\s+/g, "-")}`;
                return lookupChip(id);
              }

              // last resort: try constructing from text + type
              if (c && c.type && text) {
                const id = `${c.type}:${text
                  .toLowerCase()
                  .replace(/\s+/g, "-")}`;
                return lookupChip(id);
              }
            } catch (err) {
              console.error("Chip click handler error:", err);
            }
          });

          row.appendChild(chip);
        });

        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // ðŸ’¸ BUILD RECOMMENDATIONS (Tapable)
      function renderBuildRecommendations(results, maxBuilds = 3) {
        appendAssistant(`Here are some recommended builds you can explore:`);

        const row = document.createElement("div");
        row.className = "chip-row";

        results.slice(0, maxBuilds).forEach((build, idx) => {
          const chip = document.createElement("div");
          chip.className = "chip";

          // Use only total_price as canonical price (avoid watt numbers)
          const price = build.total_price || null;
          const priceLabel = price ? ` â€” ${formatPrice(price)}` : "";
          chip.textContent = `Build ${idx + 1}${priceLabel}`;

          chip.dataset.build = encodeURIComponent(JSON.stringify(build));
          chip.addEventListener("click", () => onBuildTap(chip));
          row.appendChild(chip);
        });

        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // âš™ï¸ COMPATIBILITY RECOMMENDATIONS (Plain text â€” non-tapable)
      // (Kept for fallback but not used in ask() by default.)
      function renderCompatibility(data) {
        if (data.results && data.results.length) {
          // Friendly header
          let out = `The ${data.target} is compatible with these ${(
            data.compatible_type || "component"
          ).toUpperCase()}s:\n\n`;

          // Render up to a reasonable preview as plain-text list (no clickable chips)
          data.results.slice(0, 12).forEach((c) => {
            const price = c.price || (c.meta && c.meta.price) || "";
            out += `- ${c.text}${price ? ` (${price})` : ""}\n`;
          });

          appendAssistant(out);
        } else {
          appendAssistant(data.message || "No compatible components found.");
        }
      }

      // ðŸ§  BUILD DETAILS (when user taps a build chip)
      function onBuildTap(chip) {
        try {
          const bstr = decodeURIComponent(chip.dataset.build || "");
          const build = JSON.parse(bstr);

          const lines = [];

          // --- Header (use total_price only)
          const total = build.total_price || null;
          const score = build.score ?? null;
          if (total) {
            const formattedTotal = `â‚±${Number(total).toLocaleString()}`;
            lines.push(`Estimated total: ${formattedTotal}`);
            lines.push(""); // blank line
          }

          // --- Component listing
          const componentOrder = [
            "cpu",
            "gpu",
            "motherboard",
            "ram",
            "storage",
            "psu",
          ];
          const seen = new Set();
          const formatLine = (label, name, price) =>
            `${label}: ${name}${price ? ` â€” ${price}` : ""}`;

          if (Array.isArray(build.chips) && build.chips.length) {
            // prefer chips.meta.name & meta.price when available
            build.chips.forEach((c) => {
              const type = (c.type || "").toLowerCase();
              const name = c.meta?.name || c.text || "";
              const price = c.meta?.price || c.price || "";
              if (componentOrder.includes(type) && !seen.has(type)) {
                const label = type.charAt(0).toUpperCase() + type.slice(1);
                lines.push(formatLine(label, name, price));
                seen.add(type);
              }
            });
          } else {
            // fallback: try build fields
            componentOrder.forEach((k) => {
              const item = build[k];
              if (item && (item.name || item.text)) {
                const name = item.name || item.text;
                const price = item.price || "";
                lines.push(formatLine(k.toUpperCase(), name, price));
              }
            });
          }

          lines.push(""); // spacing

          // --- Wattage and Recommendation
          const wattChip = (build.chips || []).find((c) =>
            (c.id || "").startsWith("build-watt:")
          );
          const recoChip = (build.chips || []).find(
            (c) =>
              (c.type || "") === "psu-recommendation" ||
              (c.id || "").startsWith("build-psu-reco:")
          );

          if (wattChip) {
            const meta = wattChip.meta || {};
            const draw = meta.total_draw || wattChip.text || "";
            lines.push(`Estimated Draw: ${draw} W`);
          }

          if (recoChip) {
            const meta = recoChip.meta || {};
            const reco = meta.recommended_watt || recoChip.text || "";
            lines.push(`Recommended PSU: ${reco} W`);
          }

          // --- Suggested PSUs (deduped)
          const psuChips = (build.chips || []).filter(
            (c) => (c.type || "").toLowerCase() === "psu"
          );
          const uniquePSUs = [];
          const seenNames = new Set();

          psuChips.forEach((p) => {
            const name = p.meta?.name || p.text || "";
            if (!seenNames.has(name)) {
              seenNames.add(name);
              uniquePSUs.push({
                name,
                price: p.meta?.price || p.price || "",
              });
            }
          });

          if (uniquePSUs.length) {
            lines.push("");
            lines.push("Suggested PSUs:");
            uniquePSUs.forEach((p) => {
              lines.push(`â€¢ ${p.name}${p.price ? ` â€” ${p.price}` : ""}`);
            });
          }

          appendAssistant(lines.join("\n"));
        } catch (err) {
          console.error("Failed to render build:", err);
          appendAssistant("âš ï¸ Could not render build details properly.");
        }
      }

      // ðŸ’° Price formatter
      function formatPrice(p) {
        if (p === null || p === undefined || p === "") return "";
        // keep strings that already have currency symbol
        if (typeof p === "string") {
          const trimmed = p.trim();
          if (trimmed.startsWith("â‚±")) return trimmed;
          // try to extract digits and format
          const digits = trimmed.replace(/[^\d]/g, "");
          if (digits) return `â‚±${Number(digits).toLocaleString()}`;
          return trimmed;
        }
        return `â‚±${Number(p).toLocaleString()}`;
      }

      // ðŸ” COMPONENT LOOKUP (when user taps a chip)
      async function lookupChip(chipId) {
        appendAssistant("ðŸ” Checking details...");
        try {
          const res = await fetch(API_BASE + "/api/lookup", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ chip_id: chipId }),
          });

          const text = await res.text();
          if (!res.ok) {
            appendAssistant(
              `âš ï¸ Lookup failed (status ${res.status})\n\n${text}`
            );
            console.error("Lookup failed:", res.status, text);
            return;
          }

          let data;
          try {
            data = text ? JSON.parse(text) : {};
          } catch (err) {
            appendAssistant("âš ï¸ Lookup returned non-JSON. See console.");
            console.error("Failed to parse lookup JSON:", err, "raw:", text);
            appendAssistant(text);
            return;
          }

          // remove the temporary "Checking details..." bubble
          const last = chat.querySelectorAll(".bubble-assistant");
          if (last.length) last[last.length - 1].remove();

          if (data.found) {
            let specs = "";
            for (const [key, val] of Object.entries(data.specs || {})) {
              specs += `${key}: ${val}\n`;
            }
            appendAssistant(`${data.name}\nPrice: ${data.price}\n${specs}`);
          } else {
            appendAssistant("Component not found.");
          }
        } catch (err) {
          console.error(err);
          appendAssistant("Lookup failed (network).");
        }
      }

      // Starter suggestions (beginner-friendly tapables)
      function showStarterSuggestions() {
        appendAssistant("Welcome to ARIA");

        const starters = [
          "Recommend me a â‚±30000 PC build",
          "What CPU is compatible with RAMSTA RS-B450MP?",
          "Show me the specs of RTX 3060",
          "What does VRAM do?",
        ];

        const row = document.createElement("div");
        row.className = "chip-row";

        starters.forEach((text) => {
          const chip = document.createElement("div");
          chip.className = "chip";
          chip.textContent = text;
          chip.onclick = () => {
            qInput.value = text;
            setTimeout(() => ask(), 100);
          };
          row.appendChild(chip);
        });

        chat.appendChild(row);
        chat.scrollTop = chat.scrollHeight;
      }

      // ðŸš€ MAIN â€” Send query to backend (robust, shows server body for debugging)
      async function ask() {
        const query = qInput.value.trim();
        if (!query) return;

        appendUser(query);
        const thinking = appendAssistant("ARIA Thinking...");

        try {
          const res = await fetch(API_BASE + "/api/recommend", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ query }),
          });

          // Read raw text first so we can show helpful debug info if parsing fails
          const text = await res.text();

          // remove thinking bubble
          if (thinking && thinking.parentNode) thinking.remove();

          if (!res.ok) {
            appendAssistant(`âš ï¸ Server error ${res.status}\n\n${text}`);
            console.error("Server returned non-OK:", res.status, text);
            qInput.value = "";
            return;
          }

          let data = null;
          try {
            data = text ? JSON.parse(text) : {};
          } catch (err) {
            appendAssistant(
              "âš ï¸ Failed to parse server response as JSON. Showing raw response:"
            );
            console.error(
              "Failed to parse JSON from server response:",
              err,
              "raw:",
              text
            );
            appendAssistant(text);
            qInput.value = "";
            return;
          }

          // ðŸ§© Handle compatibility (render TAPABLE chips)
          if (data.source === "local-compatibility") {
            if (Array.isArray(data.results) && data.results.length) {
              // Header message
              appendAssistant(
                `The ${data.target} is compatible with these ${(
                  data.compatible_type || "component"
                ).toUpperCase()} options â€” tap any item to view specs:`
              );

              // Limit displayed chips to a reasonable number to avoid UI overload
              const chipsToShow = data.results.slice(0, 12);

              // Render tapable chips; clicking looks up the chip id (falling back to constructed id)
              renderChips(
                chipsToShow,
                (c) => {
                  // prefer explicit id
                  const id =
                    c.id ||
                    (c.type && (c.meta?.name || c.text)
                      ? `${c.type}:${(c.meta?.name || c.text)
                          .toLowerCase()
                          .replace(/\s+/g, "-")}`
                      : null);
                  if (id) return lookupChip(id);
                },
                "text",
                true
              );

              // short reminder
            } else {
              // fallback message
              appendAssistant(
                data.message || "No compatible components found."
              );
            }
          }
          // âš¡ Handle PSU responses (plain text)
          else if (data.source === "local-psu") {
            let textOut = `ðŸ”Œ PSU Recommendation\n`;
            textOut += `Detected: ${
              data.detected_str || "components unknown"
            }\n\n`;
            // show per-component watts if present
            if (data.component_watts) {
              for (const [k, v] of Object.entries(data.component_watts)) {
                textOut += `  ${k}: ${v} W\n`;
              }
              textOut += `\n`;
            }
            textOut += `Estimated total draw: ${data.total_draw} W\n`;
            textOut += `Recommended PSU (with headroom): ${data.recommended_psu} W\n\n`;

            // Suggested PSUs as plain text bullets (no clickable chips)
            if (
              Array.isArray(data.suggested_psu_chips) &&
              data.suggested_psu_chips.length
            ) {
              textOut += "Suggested PSUs:\n";
              data.suggested_psu_chips.forEach((chip) => {
                const label =
                  chip.text || (chip.meta && chip.meta.name) || "PSU";
                const price =
                  chip.price || (chip.meta && chip.meta.price) || "";
                textOut += ` â€¢ ${label}${price ? ` â€” ${price}` : ""}\n`;
              });
              textOut += `\n(To inspect a PSU in detail, ask "show me specs of <PSU name>".)`;
            }

            appendAssistant(textOut);
          }
          // ðŸ’¸ Handle budget builds (only show Build chips, do NOT auto-render every component as chips)
          else if (
            data.source === "local-recommendation" &&
            Array.isArray(data.results)
          ) {
            // render build buttons only
            const normalized = data.results.map((r) => ({
              message: r.message || "",
              chips: r.chips || [],
              total_price: r.total_price || null,
              score: r.score || null,
              // keep original r for potential future use
              _orig: r,
            }));
            renderBuildRecommendations(normalized, 3);

            // Do NOT automatically render per-build component chips here.
            // Build detail rendering happens when user taps a Build chip (onBuildTap).
          }
          // Handle local-list responses (server already composes plain text lists when dataset is large)
          else if (data.source === "local-list") {
            // Prefer backend-friendly plain text in data.text; fallback to small chips if explicitly provided and small
            if (data.text) {
              appendAssistant(data.text);
            } else if (
              Array.isArray(data.results) &&
              data.results.length &&
              data.results.length <= 8
            ) {
              // small sets can be rendered as chips (optional)
              renderChips(
                data.results,
                (c) => {
                  const id = c.id || null;
                  if (id) lookupChip(id);
                },
                "text",
                true
              );
            } else {
              appendAssistant("No items found.");
            }
          }
          // ðŸ¤– Handle Gemini text answers and render any small attached chips (only if intentionally included)
          else if (data.text) {
            appendAssistant(data.text);

            // Render chips only when backend intentionally returned a small 'results' set
            if (
              Array.isArray(data.results) &&
              data.results.length &&
              data.results.length <= 8
            ) {
              renderChips(
                data.results,
                (c) => {
                  const id =
                    c.id ||
                    (c.type && (c.meta?.name || c.text)
                      ? `${c.type}:${(c.meta?.name || c.text)
                          .toLowerCase()
                          .replace(/\s+/g, "-")}`
                      : null);
                  if (id) lookupChip(id);
                },
                "text",
                true
              );
            }

            if (
              Array.isArray(data.chips) &&
              data.chips.length &&
              data.chips.length <= 8
            ) {
              renderChips(
                data.chips,
                (c) => {
                  if (c.id) lookupChip(c.id);
                },
                "text",
                true
              );
            }

            // suggested_psu_chips intentionally ignored for clickable rendering here (PSU handling above shows plain list)
          } else {
            appendAssistant("No recommendations found. Server returned:");
            appendAssistant(JSON.stringify(data, null, 2));
          }
        } catch (err) {
          console.error("Network/fetch error:", err);
          if (thinking && thinking.parentNode) thinking.remove();
          appendAssistant(
            "âš ï¸ Connection error. Check Flask server. (See console for details)"
          );
        } finally {
          qInput.value = "";
        }
      }

      // âŒ¨ï¸ UI wiring
      sendBtn.onclick = ask;
      qInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") ask();
      });

      // show starter suggestions when page loads
      window.addEventListener("load", showStarterSuggestions);
    </script>
    <div
      id="output"
      style="
        white-space: pre-wrap;
        font-family: monospace;
        padding: 12px;
        border: 1px solid #ddd;
      "
    ></div>
  </body>
</html>
